<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta content="width=device-width,initial-scale=1.0" name="viewport"/>
<title>{{.Title}}</title>
<style>
  :root {
    --bg-color: #f0f4f8;
    --card-bg: #ffffff;
    --primary: #4F46E5; /* Indigo */
    --success: #10B981; /* Emerald */
    --error: #EF4444;   /* Red */
    --text: #1F2937;
  }

  body { 
    font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
    background-color: var(--bg-color);
    color: var(--text);
    margin: 0;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .container { max-width: 700px; width: 100%; }

  h1 { text-align: center; color: #111827; }
  p.desc { text-align: center; color: #6B7280; margin-bottom: 30px; }

  /* Question Card */
  .question-card {
    background: var(--card-bg);
    border-radius: 12px;
    padding: 24px;
    margin-bottom: 20px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s;
  }

  .question-text {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 16px;
  }

  /* Custom Radio/Inputs */
  label.option {
    display: block;
    padding: 12px 16px;
    margin: 8px 0;
    background: #f9fafb;
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
  }

  label.option:hover { border-color: var(--primary); background: #eef2ff; }
  
  /* Hide actual radio button but keep accessibility */
  input[type="radio"] { accent-color: var(--primary); transform: scale(1.2); margin-right: 10px; }

  /* Feedback States */
  label.option.correct { 
    background-color: #d1fae5; 
    border-color: var(--success); 
    color: #065f46;
  }
  label.option.incorrect { 
    background-color: #fee2e2; 
    border-color: var(--error);
    opacity: 0.7;
  }
  
  /* The "Correct Answer" highlight (when user is wrong) */
  label.option.correct-answer {
    border: 2px dashed var(--success);
    font-weight: bold;
  }

  /* Text Inputs */
  input[type="text"], select {
    width: 100%;
    padding: 10px;
    font-size: 1rem;
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    box-sizing: border-box;
  }
  input[type="text"]:focus, select:focus {
    outline: none;
    border-color: var(--primary);
  }
  input[type="text"].correct { border-color: var(--success); background: #d1fae5; }
  input[type="text"].incorrect { border-color: var(--error); background: #fee2e2; }

  /* Submit Button */
  .submit-btn {
    display: block;
    width: 100%;
    padding: 16px;
    background-color: var(--primary);
    color: white;
    font-size: 1.2rem;
    font-weight: bold;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(79, 70, 229, 0.4);
    margin-top: 20px;
  }
  .submit-btn:hover { background-color: #4338ca; }

  /* Score Banner (Hidden by default) */
  #score-banner {
    display: none;
    margin-top: 20px;
    padding: 20px;
    text-align: center;
    background: #111827;
    color: white;
    border-radius: 12px;
    font-size: 1.2rem;
  }
</style>
</head>
<body>

<h1>{{.Title}}</h1>
<p>{{.Instructions}}</p>

<form id="worksheetForm">
{{range $i, $q := .Questions}}
  <div class="question">
    <p>{{$i | inc}}. {{$q.Text}}</p>

    {{if eq $q.Type 2}}
      {{range $j, $opt := $q.Options}}
        <label for="q{{$i}}"><input type="radio" id="q{{$i}}" name="q{{$i}}" value="{{$opt}}" data-correct="{{$q.Correct}}" />{{$opt}}</label><br>
      {{end}}

    {{else if eq $q.Type 1}}
      <select name="q{{$i}}" data-correct="{{$q.Correct}}">
        <option value="" selected disabled hidden>Choose your Answer</option>
        {{range $opt := $q.Options}}
          <option>{{$opt}}</option>
        {{end}}
      </select>

    {{else if eq $q.Type 0}}
      <input type="text" name="q{{$i}}" data-correct="{{$q.Correct}}">
    {{end}}
  </div>
{{end}}

<button type="submit">Check Answers</button>
</form>
<!-- CSS: paste in <head> -->
<style>
  /* radio option feedback */
  label.option { display: inline-block; padding: 6px 8px; border-radius: 6px; margin: 4px 0; }
  label.option.correct { background: #c8e6c9; }        /* chosen & correct */
  label.option.incorrect { background: #ffcdd2; }      /* chosen & incorrect */
  label.option.correct-answer { outline: 2px solid #4CAF50; } /* highlight correct one */

  /* fallback for non-radio inputs */
  input[type="text"].correct, select.correct { background: #c8e6c9; }
  input[type="text"].incorrect, select.incorrect { background: #ffcdd2; }

  /* small accessibility / spacing */
  .question .options { margin-top: 6px; }
</style>

<!-- JS: paste before </body> -->
<script>
document.addEventListener("DOMContentLoaded", function() {
  const form = document.getElementById("worksheetForm");
  form.addEventListener("submit", function(e) {
    e.preventDefault();

    let score = 0;
    const qDivs = document.querySelectorAll(".question");

    // helper to normalize correct answer that might be "B" or actual option text
    function resolveCorrectForRadios(rawCorrect, radios) {
      if (!rawCorrect) return "";
      // if single letter like A/B/C -> convert to option value by index
      const letterMatch = /^[A-Za-z]$/.test(rawCorrect);
      if (letterMatch) {
        const idx = rawCorrect.toUpperCase().charCodeAt(0) - 65;
        if (idx >= 0 && idx < radios.length) return radios[idx].value;
      }
      // if it's a number index like "1" treat as 0-based index
      if (/^\d+$/.test(rawCorrect)) {
        const idx = parseInt(rawCorrect, 10);
        if (idx >= 0 && idx < radios.length) return radios[idx].value;
      }
      // otherwise assume it's the option text/value itself
      return rawCorrect;
    }

    // reset all previous feedback classes
    qDivs.forEach(qd => {
      qd.querySelectorAll("label.option").forEach(l => {
        l.classList.remove("correct", "incorrect", "correct-answer");
      });
      qd.querySelectorAll("input[type=text], select").forEach(el => {
        el.classList.remove("correct", "incorrect");
      });
    });

    qDivs.forEach(qDiv => {
      // prefer data-correct on the question container; fallback to inputs/selects
      let rawCorrect = qDiv.dataset.correct || "";
      const radios = Array.from(qDiv.querySelectorAll('input[type="radio"]'));
      const select = qDiv.querySelector('select');
      const text = qDiv.querySelector('input[type="text"]');

      if (radios.length > 0) {
        // if no container-level correct provided, try any radio with data-correct
        if (!rawCorrect) {
          const found = radios.find(r => r.dataset.correct);
          rawCorrect = found ? found.dataset.correct : "";
        }

        const correctValue = resolveCorrectForRadios(rawCorrect, radios);

        const checked = qDiv.querySelector('input[type="radio"]:checked');

        // mark correct option for learning (outline)
        if (correctValue) {
          const correctInput = radios.find(r => r.value === correctValue);
          if (correctInput) {
            const correctLabel = correctInput.closest('label');
            if (correctLabel) correctLabel.classList.add('correct-answer');
          }
        }

        if (checked) {
          const chosenValue = checked.value;
          const chosenLabel = checked.closest('label');

          if (chosenValue === correctValue) {
            if (chosenLabel) chosenLabel.classList.add('correct');
            score++;
          } else {
            if (chosenLabel) chosenLabel.classList.add('incorrect');
          }
        } else {
          // nothing chosen: optionally reveal correct answer only (done above)
        }

      } else if (select) {
        // selects
        // check dataset on select first, then check children
        let corr = select.dataset.correct || rawCorrect || "";
        const userVal = select.value;
        if (userVal && corr) {
          // normalize letter/index if necessary
          if (/^[A-Za-z]$/.test(corr)) {
            // try to map corr letter to option value
            const options = Array.from(select.options).filter(o => o.value !== "");
            const idx = corr.toUpperCase().charCodeAt(0) - 65;
            if (idx >= 0 && idx < options.length) corr = options[idx].value;
          }
          if (userVal === corr) {
            select.classList.add('correct'); score++;
          } else select.classList.add('incorrect');
        }
      } else if (text) {
        // text inputs
        let corr = text.dataset.correct || rawCorrect || "";
        const val = text.value.trim();
        if (val && corr) {
          if (val === corr) { text.classList.add('correct'); score++; }
          else text.classList.add('incorrect');
        }
      }
    });
  }, false);
});
</script>

</body>
</html>